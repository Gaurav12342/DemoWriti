{"ast":null,"code":"var _jsxFileName = \"/home/gauravpendherkar/DemoWriti/src/containers/MainApp.js\";\nimport React, { useEffect } from 'react';\nimport { withRouter, useParams } from \"react-router-dom\";\nimport ProtectedRoutes from '../routes/ProtectedRoutes';\nimport PublicRoutes from '../routes/PublicRoutes';\nimport Routes from \"../routes/index.js\";\nimport { connect, useSelector } from 'react-redux';\nimport { ToastContainer } from 'react-toastify';\nimport routes from '../routes/constant';\nimport { getUserBaseRedirect, clearLocalStorage, userLogout } from '../util/common';\nimport CacheBuster from './CacheBuster';\nimport SocketConfig, { isSetSocketQuery } from '../services/socket/config';\nimport { CURRENT_VERSION } from '../constants/versionControl';\nimport { PUBLIC_ROUTES_COLLECTIONS } from '../constants/common';\nimport { setSocket, setToken } from '../appRedux/actions/Auth';\nimport { decryptData } from '../util/Crypto';\nimport { Toast } from '../components/common';\nimport instance from '../services/api/config';\nimport CommonService, { getApiUrl } from '../services/api/services/common';\nimport { tokenRefresh } from '../services/api/routes/auth';\nimport { isPharmacyUser } from '../constants/User';\n\nconst MainApp = props => {\n  const {\n    match,\n    token,\n    location,\n    authUser,\n    otpVerified,\n    defaultPassword,\n    socket,\n    setSocket,\n    setToken\n  } = props;\n  const socketIns = useSelector(state => state.auth.socket);\n  console.log(\"MainApp -> socketIns\", socketIns);\n  useEffect(() => {\n    versionUpdates();\n  }, []); // useEffect(() => {\n  //   console.log(\"=============================\")\n  //   let previousRequest = {};\n  //   //request interceptors\n  //   instance.interceptors.request.use(\n  //     (config) => {\n  //       let tenantId\n  //       let excludeTenant = JSON.parse(localStorage.getItem('excludeTenant')) || false;\n  //       tenantId = excludeTenant ? localStorage.getItem('tenantId') : undefined;\n  //       const homeId = excludeTenant ? localStorage.getItem('homeId') : undefined;\n  //       const token = JSON.parse(localStorage.getItem('token'));\n  //       if (!config.headers.Authorization)\n  //         config.headers.Authorization = token ? `JWT ${token}` : '';\n  //       if (!config.headers.isCustom) {\n  //         const authUser = decryptData(localStorage.getItem('user'));\n  //         config.headers.homeIdentifier = tenantId || '';\n  //         config.headers.homeId = homeId;\n  //         if (authUser)\n  //           config.headers.pharmacyId = isPharmacyUser(authUser.type) ? authUser?.pharmacyId?._id : authUser?.homeId?.pharmacyId?._id;\n  //       }\n  //       delete config.headers.isCustom\n  //       if (process.env.PUBLIC_URL === 'production') config.baseURL = '/';\n  //       return config;\n  //     },\n  //     (error) => Promise.reject(error)\n  //   );\n  //   //response interceptors\n  // instance.interceptors.response.use(\n  //   (response) => Promise.resolve(response),\n  //   (error) => {\n  //     console.log(\"=======5555======================\")\n  //     if (!error.response)\n  //       Toast.error(error.message || 'Network error - something went wrong');\n  //     if (error.response && error.response.data) {\n  //       if (error.response.data.code !== 'E_INVALID_TOKEN')\n  //         Toast.error(error.response.data.message);\n  //       if (error.response.data.code === 'E_UNAUTHORIZED') {\n  //         userLogout();\n  //       } else if (error.response.data.code === 'E_INVALID_TOKEN') {\n  //         //refresh token\n  //         const { method, url } = tokenRefresh;\n  //         const user = decryptData(localStorage.getItem('user'));\n  //         let token = localStorage.getItem('refreshToken');\n  //         const req = {\n  //           refreshToken: 'jwt ' + JSON.parse(token),\n  //         };\n  //         let canCall = true;\n  //         if (previousRequest && previousRequest.url) {\n  //           if (previousRequest.url !== error.config.url) {\n  //             previousRequest = error.config;\n  //           } else {\n  //             canCall = false;\n  //           }\n  //         } else {\n  //           previousRequest = error.config;\n  //         }\n  //         if (canCall) {\n  //           let tokenResponse = CommonService({\n  //             ...tokenRefresh,\n  //             method,\n  //             url,\n  //             data: req,\n  //           }).then(async (data) => {\n  //             if (data && data.code === 'OK') {\n  //               if (socketIns) {\n  //                 socketIns.disconnect()\n  //               }\n  //               setSocket(null)\n  //               localStorage.setItem('token', JSON.stringify(data.data.token));\n  //               previousRequest.headers['Authorization'] = 'JWT ' + data.data.token;\n  //               setToken(data.data.token)\n  //               let res = await instance(previousRequest); // call API which had return expire token error\n  //               return Promise.resolve(res);\n  //             }\n  //           });\n  //           if (tokenResponse) return Promise.resolve(tokenResponse);\n  //         }\n  //       } else {\n  //       }\n  //     }\n  //     return Promise.reject(error);\n  //   }\n  // );\n  // }, [socketIns, token])\n\n  useEffect(() => {\n    const excludeOTPVerification = JSON.parse(localStorage.getItem('excludeOTPVerification'));\n\n    if (token && !excludeOTPVerification && !otpVerified) {\n      setTimeout(() => {\n        clearLocalStorage();\n        RedirectTo(routes.login.path);\n      }, 600000);\n    }\n  }, [token]);\n  useEffect(() => {\n    if (!authUser) return;\n    if (socket || !isSetSocketQuery()) return;\n    let insatnce = SocketConfig();\n    setSocket(insatnce);\n    insatnce.on('connect', e => {\n      console.log(\"SOCKET CONNECTED\", e);\n    });\n    insatnce.on('disconnect', e => {\n      console.log(\"SOCKET DISCONNECTED\");\n      console.log(authUser, socket);\n    });\n    insatnce.on('errors', data => {\n      console.log(\"SOCKET ERRORS\", data);\n\n      if (!data.flag) {\n        if (data.message.code === \"E_UNAUTHORIZED\") {// Toast.error(data.message.message)\n          // userLogout();\n        }\n      }\n    });\n    insatnce.on('error', data => {\n      console.log(\"SOCKET ERORR\", data);\n    }); // Listen for possible errors\n\n    insatnce.addEventListener('error', function (event) {\n      console.log('WebSocket error: ', event);\n    });\n    insatnce.addEventListener('close', function (event) {\n      console.log('The connection has been closed successfully.');\n    });\n    insatnce.addEventListener('open', function (event) {\n      console.log('The connection has been closed successfully.');\n    });\n    insatnce.addEventListener('message', function (event) {\n      console.log('The connection has been closed successfully.');\n    });\n  }, [token, authUser]);\n\n  const versionUpdates = () => {\n    if (window.localStorage.length === 0) {\n      if (!localStorage.getItem('latestVersion')) {\n        localStorage.setItem('latestVersion', CURRENT_VERSION);\n      }\n    } else if (!localStorage.getItem('latestVersion')) {\n      localStorage.setItem('latestVersion', CURRENT_VERSION);\n    }\n  };\n\n  function RedirectTo(path) {\n    props.history.push({\n      pathname: path\n    });\n  }\n\n  const canRedirectToOtpPage = () => {\n    return authUser && token && !authUser.excludeOTPVerification && !otpVerified;\n  };\n\n  const getRouteRedirect = () => {\n    if (token === null && !authUser) {\n      RedirectTo(routes.login.path);\n    } else if (canRedirectToOtpPage()) {\n      RedirectTo(routes.verifyOtp.path);\n    } else if (authUser && Object.keys(authUser).length > 0) {\n      RedirectTo(getUserBaseRedirect(authUser));\n    } else {\n      RedirectTo(routes.pageNotFound.path);\n    }\n  };\n\n  if (localStorage.getItem('user')) {\n    const tempUser = decryptData(localStorage.getItem('user'));\n\n    if (tempUser && tempUser.defaultPassword && location.pathname !== routes.updateDefaultPassword.path) {\n      RedirectTo(routes.updateDefaultPassword.path);\n    }\n  }\n\n  if (location.pathname === '/') {\n    getRouteRedirect();\n  } else if (PUBLIC_ROUTES_COLLECTIONS.indexOf(location.pathname) < 0) {\n    if (location.pathname.indexOf('wa/reset-password') < 0) {\n      let ispathFound;\n      Object.keys(routes).some(k => {\n        if (routes[k].path === location.pathname || location.pathname.indexOf(routes[k].path)) {\n          ispathFound = routes[k].path;\n          return true;\n        }\n      });\n\n      if (ispathFound === undefined) {\n        RedirectTo(routes.pageNotFound.path);\n      } else if (PUBLIC_ROUTES_COLLECTIONS.indexOf(ispathFound) < 0 && !authUser) {\n        getRouteRedirect();\n      }\n    }\n  }\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(CacheBuster, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 256,\n      columnNumber: 5\n    }\n  }, ({\n    loading,\n    isLatestVersion,\n    refreshCacheAndReload\n  }) => {\n    if (loading) return null;\n\n    if (!loading && !isLatestVersion) {\n      refreshCacheAndReload();\n    }\n\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(PublicRoutes, Object.assign({}, props, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(ProtectedRoutes, Object.assign({\n      path: match.url,\n      component: Routes,\n      match: match\n    }, props, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 270,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(ToastContainer, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 272,\n        columnNumber: 13\n      }\n    }));\n  }));\n};\n\nconst mapStateToProps = ({\n  auth\n}) => {\n  console.log(\"mapStateToProps -> auth\", auth);\n  const {\n    preferredLanguage,\n    token,\n    defaultPassword,\n    otpVerified,\n    authUser,\n    socket\n  } = auth;\n  return {\n    preferredLanguage,\n    token,\n    defaultPassword,\n    otpVerified,\n    authUser,\n    socket\n  };\n};\n\nexport default withRouter(connect(mapStateToProps, {\n  setSocket,\n  setToken\n})(MainApp));","map":{"version":3,"sources":["/home/gauravpendherkar/DemoWriti/src/containers/MainApp.js"],"names":["React","useEffect","withRouter","useParams","ProtectedRoutes","PublicRoutes","Routes","connect","useSelector","ToastContainer","routes","getUserBaseRedirect","clearLocalStorage","userLogout","CacheBuster","SocketConfig","isSetSocketQuery","CURRENT_VERSION","PUBLIC_ROUTES_COLLECTIONS","setSocket","setToken","decryptData","Toast","instance","CommonService","getApiUrl","tokenRefresh","isPharmacyUser","MainApp","props","match","token","location","authUser","otpVerified","defaultPassword","socket","socketIns","state","auth","console","log","versionUpdates","excludeOTPVerification","JSON","parse","localStorage","getItem","setTimeout","RedirectTo","login","path","insatnce","on","e","data","flag","message","code","addEventListener","event","window","length","setItem","history","push","pathname","canRedirectToOtpPage","getRouteRedirect","verifyOtp","Object","keys","pageNotFound","tempUser","updateDefaultPassword","indexOf","ispathFound","some","k","undefined","loading","isLatestVersion","refreshCacheAndReload","url","mapStateToProps","preferredLanguage"],"mappings":"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","sourcesContent":["import React, { useEffect } from 'react';\nimport { withRouter, useParams } from \"react-router-dom\";\nimport ProtectedRoutes from '../routes/ProtectedRoutes'\nimport PublicRoutes from '../routes/PublicRoutes'\nimport Routes from \"../routes/index.js\";\nimport { connect, useSelector } from 'react-redux'\nimport { ToastContainer } from 'react-toastify'\nimport routes from '../routes/constant';\nimport { getUserBaseRedirect, clearLocalStorage, userLogout } from '../util/common';\nimport CacheBuster from './CacheBuster'\nimport SocketConfig, { isSetSocketQuery } from '../services/socket/config'\nimport { CURRENT_VERSION } from '../constants/versionControl';\nimport { PUBLIC_ROUTES_COLLECTIONS } from '../constants/common'\nimport { setSocket, setToken } from '../appRedux/actions/Auth'\nimport { decryptData } from '../util/Crypto';\nimport { Toast } from '../components/common'\nimport instance from '../services/api/config'\nimport CommonService, { getApiUrl } from '../services/api/services/common';\nimport { tokenRefresh } from '../services/api/routes/auth';\nimport { isPharmacyUser } from '../constants/User'\n\nconst MainApp = (props) => {\n  const {\n    match,\n    token,\n    location,\n    authUser,\n    otpVerified,\n    defaultPassword,\n    socket,\n    setSocket,\n    setToken\n  } = props;\n\n  const socketIns = useSelector(state => state.auth.socket)\n  console.log(\"MainApp -> socketIns\", socketIns)\n\n  useEffect(() => {\n    versionUpdates()\n  }, [])\n  // useEffect(() => {\n  //   console.log(\"=============================\")\n  //   let previousRequest = {};\n  //   //request interceptors\n  //   instance.interceptors.request.use(\n  //     (config) => {\n\n  //       let tenantId\n  //       let excludeTenant = JSON.parse(localStorage.getItem('excludeTenant')) || false;\n  //       tenantId = excludeTenant ? localStorage.getItem('tenantId') : undefined;\n  //       const homeId = excludeTenant ? localStorage.getItem('homeId') : undefined;\n  //       const token = JSON.parse(localStorage.getItem('token'));\n  //       if (!config.headers.Authorization)\n  //         config.headers.Authorization = token ? `JWT ${token}` : '';\n  //       if (!config.headers.isCustom) {\n  //         const authUser = decryptData(localStorage.getItem('user'));\n  //         config.headers.homeIdentifier = tenantId || '';\n  //         config.headers.homeId = homeId;\n  //         if (authUser)\n  //           config.headers.pharmacyId = isPharmacyUser(authUser.type) ? authUser?.pharmacyId?._id : authUser?.homeId?.pharmacyId?._id;\n  //       }\n  //       delete config.headers.isCustom\n\n  //       if (process.env.PUBLIC_URL === 'production') config.baseURL = '/';\n  //       return config;\n  //     },\n  //     (error) => Promise.reject(error)\n  //   );\n\n  //   //response interceptors\n  // instance.interceptors.response.use(\n  //   (response) => Promise.resolve(response),\n  //   (error) => {\n  //     console.log(\"=======5555======================\")\n  //     if (!error.response)\n  //       Toast.error(error.message || 'Network error - something went wrong');\n  //     if (error.response && error.response.data) {\n  //       if (error.response.data.code !== 'E_INVALID_TOKEN')\n  //         Toast.error(error.response.data.message);\n  //       if (error.response.data.code === 'E_UNAUTHORIZED') {\n  //         userLogout();\n  //       } else if (error.response.data.code === 'E_INVALID_TOKEN') {\n  //         //refresh token\n  //         const { method, url } = tokenRefresh;\n  //         const user = decryptData(localStorage.getItem('user'));\n  //         let token = localStorage.getItem('refreshToken');\n  //         const req = {\n  //           refreshToken: 'jwt ' + JSON.parse(token),\n  //         };\n  //         let canCall = true;\n  //         if (previousRequest && previousRequest.url) {\n  //           if (previousRequest.url !== error.config.url) {\n  //             previousRequest = error.config;\n  //           } else {\n  //             canCall = false;\n  //           }\n  //         } else {\n  //           previousRequest = error.config;\n  //         }\n  //         if (canCall) {\n  //           let tokenResponse = CommonService({\n  //             ...tokenRefresh,\n  //             method,\n  //             url,\n  //             data: req,\n  //           }).then(async (data) => {\n  //             if (data && data.code === 'OK') {\n  //               if (socketIns) {\n  //                 socketIns.disconnect()\n  //               }\n  //               setSocket(null)\n  //               localStorage.setItem('token', JSON.stringify(data.data.token));\n  //               previousRequest.headers['Authorization'] = 'JWT ' + data.data.token;\n  //               setToken(data.data.token)\n  //               let res = await instance(previousRequest); // call API which had return expire token error\n  //               return Promise.resolve(res);\n  //             }\n  //           });\n  //           if (tokenResponse) return Promise.resolve(tokenResponse);\n  //         }\n  //       } else {\n\n  //       }\n  //     }\n  //     return Promise.reject(error);\n  //   }\n  // );\n  // }, [socketIns, token])\n\n  useEffect(() => {\n\n    const excludeOTPVerification = JSON.parse(localStorage.getItem('excludeOTPVerification'))\n    if (token && !excludeOTPVerification && !otpVerified) {\n      setTimeout(() => {\n        clearLocalStorage()\n        RedirectTo(routes.login.path)\n      }, 600000)\n    }\n  }, [token])\n\n  useEffect(() => {\n\n    if (!authUser)\n      return\n    if (socket || !isSetSocketQuery())\n      return\n    let insatnce = SocketConfig()\n    setSocket(insatnce)\n    insatnce.on('connect', (e) => {\n      console.log(\"SOCKET CONNECTED\", e)\n    })\n    insatnce.on('disconnect', (e) => {\n      console.log(\"SOCKET DISCONNECTED\")\n      console.log(authUser, socket)\n    })\n\n    insatnce.on('errors', (data) => {\n      console.log(\"SOCKET ERRORS\", data)\n      if (!data.flag) {\n        if (data.message.code === \"E_UNAUTHORIZED\") {\n          // Toast.error(data.message.message)\n          // userLogout();\n        }\n      }\n    })\n\n    insatnce.on('error', (data) => {\n      console.log(\"SOCKET ERORR\", data)\n    })\n\n    // Listen for possible errors\n    insatnce.addEventListener('error', function (event) {\n      console.log('WebSocket error: ', event);\n    })\n\n    insatnce.addEventListener('close', function (event) {\n      console.log('The connection has been closed successfully.');\n    })\n    insatnce.addEventListener('open', function (event) {\n      console.log('The connection has been closed successfully.');\n    })\n    insatnce.addEventListener('message', function (event) {\n      console.log('The connection has been closed successfully.');\n    })\n\n  }, [token, authUser])\n\n  const versionUpdates = () => {\n    if (window.localStorage.length === 0) {\n      if (!localStorage.getItem('latestVersion')) {\n        localStorage.setItem('latestVersion', CURRENT_VERSION)\n      }\n    }\n    else if (!localStorage.getItem('latestVersion')) {\n      localStorage.setItem('latestVersion', CURRENT_VERSION)\n    }\n  }\n\n  function RedirectTo(path) {\n    props.history.push({\n      pathname: path\n    })\n  }\n\n  const canRedirectToOtpPage = () => {\n    return (authUser && token && (!authUser.excludeOTPVerification && !otpVerified))\n  }\n\n  const getRouteRedirect = () => {\n    if (token === null && !authUser) {\n      RedirectTo(routes.login.path)\n    }\n    else if (canRedirectToOtpPage()) {\n      RedirectTo(routes.verifyOtp.path)\n    }\n    else if (authUser && Object.keys(authUser).length > 0) {\n      RedirectTo(getUserBaseRedirect(authUser))\n    }\n    else {\n      RedirectTo(routes.pageNotFound.path)\n    }\n  }\n\n\n  if (localStorage.getItem('user')) {\n    const tempUser = decryptData(localStorage.getItem('user'))\n    if (tempUser && tempUser.defaultPassword && location.pathname !== routes.updateDefaultPassword.path) {\n      RedirectTo(routes.updateDefaultPassword.path)\n    }\n  }\n\n\n  if (location.pathname === '/') {\n    getRouteRedirect()\n  }\n  else if (PUBLIC_ROUTES_COLLECTIONS.indexOf(location.pathname) < 0) {\n    if (location.pathname.indexOf('wa/reset-password') < 0) {\n      let ispathFound\n      Object.keys(routes).some(k => {\n        if (routes[k].path === location.pathname || location.pathname.indexOf(routes[k].path)) {\n          ispathFound = routes[k].path\n          return true\n        }\n      })\n\n      if (ispathFound === undefined) {\n        RedirectTo(routes.pageNotFound.path)\n      }\n      else if (PUBLIC_ROUTES_COLLECTIONS.indexOf(ispathFound) < 0 && !authUser) {\n        getRouteRedirect()\n      }\n    }\n  }\n\n  return <>\n    <CacheBuster>\n      {\n        ({ loading, isLatestVersion, refreshCacheAndReload }) => {\n          if (loading) return null\n          if (!loading && !isLatestVersion) {\n            refreshCacheAndReload()\n          }\n          return (<>\n            <PublicRoutes {...props} />\n            {/* {\n            token && authUser &&\n            (authUser.excludeOTPVerification || (!authUser.excludeOTPVerification) && otpVerified) && <ProtectedRoutes path={match.url} authUser={authUser} component={Routes} match={match}\n              {...props} />\n          } */}\n            <ProtectedRoutes path={match.url} component={Routes} match={match}\n              {...props} />\n            <ToastContainer />\n          </>)\n        }\n      }\n    </CacheBuster>\n\n  </>\n};\nconst mapStateToProps = ({ auth }) => {\n  console.log(\"mapStateToProps -> auth\", auth)\n  const { preferredLanguage, token, defaultPassword, otpVerified, authUser, socket } = auth;\n  return { preferredLanguage, token, defaultPassword, otpVerified, authUser, socket };\n};\nexport default withRouter(connect(mapStateToProps, { setSocket, setToken })(MainApp));\n"]},"metadata":{},"sourceType":"module"}